# ═══════════════════════════════════════════════════════════
# ENOVA CI/CD Pipeline
# GitHub Actions workflow with Blue-Green deployment
# ═══════════════════════════════════════════════════════════

name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  K8S_NAMESPACE: enova

jobs:
  # ─────────────────────────────────────────────────────────
  # Stage 1: Lint & Test
  # ─────────────────────────────────────────────────────────
  lint-test:
    name: Lint & Test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: "**/package-lock.json"

      - name: Install dependencies (Backend)
        working-directory: enova-backend
        run: npm ci

      - name: Lint Backend
        working-directory: enova-backend
        run: npm run lint

      - name: Test Backend
        working-directory: enova-backend
        run: npm run test

      - name: Install dependencies (Frontend)
        working-directory: .
        run: npm ci

      - name: Lint Frontend
        working-directory: .
        run: npm run lint

      - name: Test Frontend
        working-directory: .
        run: npm run test -- --passWithNoTests

  # ─────────────────────────────────────────────────────────
  # Stage 2: Build Docker Images
  # ─────────────────────────────────────────────────────────
  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: lint-test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    permissions:
      contents: read
      packages: write

    strategy:
      matrix:
        service:
          - name: api-gateway
            context: enova-backend
            dockerfile: enova-backend/docker/backend.Dockerfile
          - name: auth-service
            context: enova-backend
            dockerfile: enova-backend/docker/backend.Dockerfile
          - name: community-service
            context: enova-backend
            dockerfile: enova-backend/docker/backend.Dockerfile
          - name: chat-service
            context: enova-backend
            dockerfile: enova-backend/docker/backend.Dockerfile
          - name: frontend
            context: .
            dockerfile: docker/frontend.Dockerfile

    outputs:
      image_tag: ${{ steps.meta.outputs.version }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Convert repo name to lowercase
        id: repo
        run: echo "name=${GITHUB_REPOSITORY,,}" >> $GITHUB_OUTPUT

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ steps.repo.outputs.name }}/${{ matrix.service.name }}
          tags: |
            type=sha,prefix=
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.service.context }}
          file: ${{ matrix.service.dockerfile }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            SERVICE_NAME=${{ matrix.service.name }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: build
    # Re-enabled for DigitalOcean deployment
    if: github.ref == 'refs/heads/main'

    environment:
      name: production
      url: https://enova.app

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: "v1.28.0"

      - name: Configure kubeconfig
        run: |
          mkdir -p ~/.kube
          if [ -z "${{ secrets.KUBECONFIG }}" ]; then
            echo "::error::KUBECONFIG secret is not set in GitHub Secrets!"
            exit 1
          fi
          echo "${{ secrets.KUBECONFIG }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config

      - name: Verify Cluster Connection
        run: |
          kubectl cluster-info
          kubectl get nodes

      - name: Get image tag
        id: tag
        run: echo "TAG=$(echo ${{ github.sha }} | cut -c1-7)" >> $GITHUB_OUTPUT

      # ─────────────────────────────────────────────────────
      # Blue-Green Deployment Strategy
      # ─────────────────────────────────────────────────────
      - name: Determine deployment color
        id: color
        run: |
          CURRENT=$(kubectl get svc api-gateway -n ${{ env.K8S_NAMESPACE }} -o jsonpath='{.spec.selector.version}' 2>/dev/null || echo "blue")
          if [ "$CURRENT" = "blue" ]; then
            echo "NEW_COLOR=green" >> $GITHUB_OUTPUT
            echo "OLD_COLOR=blue" >> $GITHUB_OUTPUT
          else
            echo "NEW_COLOR=blue" >> $GITHUB_OUTPUT
            echo "OLD_COLOR=green" >> $GITHUB_OUTPUT
          fi

      - name: Deploy to new color (Green)
        run: |
          # Update image tags in manifests (convert repo name to lowercase)
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          find k8s/services -name "*.yaml" -exec sed -i \
            -e "s|\${REGISTRY}|${{ env.REGISTRY }}/${REPO_LOWER}|g" \
            -e "s|\${IMAGE_TAG}|${{ steps.tag.outputs.TAG }}|g" {} \;

          # Create namespace first and wait for it to be ready
          kubectl apply -f k8s/base/namespace.yaml
          kubectl wait --for=jsonpath='{.status.phase}'=Active namespace/enova --timeout=30s

          # Create GHCR pull secret for private images
          kubectl create secret docker-registry ghcr-credentials \
            --docker-server=ghcr.io \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.GITHUB_TOKEN }} \
            --namespace=enova --dry-run=client -o yaml | kubectl apply -f -

          # Apply configmap
          kubectl apply -f k8s/base/configmap.yaml

          # Create secrets from GitHub Secrets (not from placeholder file)
          kubectl create secret generic enova-secrets \
            --from-literal=SUPABASE_URL="${{ secrets.SUPABASE_URL }}" \
            --from-literal=SUPABASE_ANON_KEY="${{ secrets.SUPABASE_ANON_KEY }}" \
            --from-literal=SUPABASE_SERVICE_ROLE_KEY="${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
            --from-literal=SUPABASE_JWT_SECRET="${{ secrets.SUPABASE_JWT_SECRET }}" \
            --from-literal=AUTH_DATABASE_URL="${{ secrets.AUTH_DATABASE_URL }}" \
            --from-literal=COMMUNITY_DATABASE_URL="${{ secrets.COMMUNITY_DATABASE_URL }}" \
            --from-literal=CHAT_DATABASE_URL="${{ secrets.CHAT_DATABASE_URL }}" \
            --from-literal=RABBITMQ_DEFAULT_USER="${{ secrets.RABBITMQ_DEFAULT_USER }}" \
            --from-literal=RABBITMQ_DEFAULT_PASS="${{ secrets.RABBITMQ_DEFAULT_PASS }}" \
            --from-literal=REDIS_PASSWORD="${{ secrets.REDIS_PASSWORD }}" \
            --from-literal=INTERNAL_SERVICE_KEY="${{ secrets.INTERNAL_SERVICE_KEY }}" \
            --from-literal=JWT_SECRET="${{ secrets.JWT_SECRET }}" \
            --namespace=enova --dry-run=client -o yaml | kubectl apply -f -

          # Restart RabbitMQ to pick up new secrets
          kubectl rollout restart deployment/rabbitmq -n ${{ env.K8S_NAMESPACE }}
          kubectl rollout status deployment/rabbitmq -n ${{ env.K8S_NAMESPACE }} --timeout=120s

          # Delete deployments that need probe type changes (HTTP->TCP)
          # This forces recreation instead of patching which fails when changing probe types
          kubectl delete deployment auth-service -n ${{ env.K8S_NAMESPACE }} --ignore-not-found=true
          kubectl delete deployment community-service -n ${{ env.K8S_NAMESPACE }} --ignore-not-found=true
          kubectl delete deployment chat-service -n ${{ env.K8S_NAMESPACE }} --ignore-not-found=true

          # Apply service deployments
          kubectl apply -f k8s/services/ -R

          # Deploy monitoring stack (Prometheus + Grafana)
          kubectl apply -f k8s/monitoring/

      - name: Wait for rollout
        id: rollout
        continue-on-error: true
        run: |
          kubectl rollout status deployment/api-gateway -n ${{ env.K8S_NAMESPACE }} --timeout=300s
          kubectl rollout status deployment/auth-service -n ${{ env.K8S_NAMESPACE }} --timeout=300s
          kubectl rollout status deployment/community-service -n ${{ env.K8S_NAMESPACE }} --timeout=300s
          kubectl rollout status deployment/chat-service -n ${{ env.K8S_NAMESPACE }} --timeout=300s

      - name: Debug pod failure
        if: steps.rollout.outcome == 'failure'
        run: |
          echo "=== Pod Status ==="
          kubectl get pods -n ${{ env.K8S_NAMESPACE }} -o wide
          echo ""
          echo "=== Describe api-gateway pod ==="
          kubectl describe pod -n ${{ env.K8S_NAMESPACE }} -l app=api-gateway
          echo ""
          echo "=== api-gateway logs ==="
          kubectl logs -n ${{ env.K8S_NAMESPACE }} -l app=api-gateway --tail=50 || echo "No logs available"
          echo ""
          echo "=== auth-service logs ==="
          kubectl logs -n ${{ env.K8S_NAMESPACE }} -l app=auth-service --tail=50 || echo "No logs available"
          echo ""
          echo "=== chat-service logs ==="
          kubectl logs -n ${{ env.K8S_NAMESPACE }} -l app=chat-service --tail=50 || echo "No logs available"
          echo ""
          echo "=== community-service logs ==="
          kubectl logs -n ${{ env.K8S_NAMESPACE }} -l app=community-service --tail=50 || echo "No logs available"
          echo ""
          echo "=== Events ==="
          kubectl get events -n ${{ env.K8S_NAMESPACE }} --sort-by='.lastTimestamp' | tail -30
          exit 1

      - name: Run smoke tests
        id: smoke
        run: |
          # Wait for pods to be ready
          sleep 30

          # Test health endpoints
          GATEWAY_POD=$(kubectl get pod -n ${{ env.K8S_NAMESPACE }} -l app=api-gateway -o jsonpath='{.items[0].metadata.name}')
          kubectl exec -n ${{ env.K8S_NAMESPACE }} $GATEWAY_POD -- wget -q -O- http://localhost:3000/health

          echo "Smoke tests passed"

      - name: Switch traffic to new color
        if: steps.smoke.outcome == 'success'
        run: |
          # Update service selector to point to new deployment
          kubectl patch svc api-gateway -n ${{ env.K8S_NAMESPACE }} \
            -p '{"spec":{"selector":{"version":"${{ steps.color.outputs.NEW_COLOR }}"}}}'

          kubectl patch svc auth-service -n ${{ env.K8S_NAMESPACE }} \
            -p '{"spec":{"selector":{"version":"${{ steps.color.outputs.NEW_COLOR }}"}}}'

          kubectl patch svc community-service -n ${{ env.K8S_NAMESPACE }} \
            -p '{"spec":{"selector":{"version":"${{ steps.color.outputs.NEW_COLOR }}"}}}'

          kubectl patch svc chat-service -n ${{ env.K8S_NAMESPACE }} \
            -p '{"spec":{"selector":{"version":"${{ steps.color.outputs.NEW_COLOR }}"}}}'

      - name: Scale down old deployment
        if: steps.smoke.outcome == 'success'
        run: |
          # Keep old deployment at 1 replica for quick rollback
          kubectl scale deployment -n ${{ env.K8S_NAMESPACE }} \
            -l version=${{ steps.color.outputs.OLD_COLOR }} --replicas=1 || true

      - name: Rollback on failure
        if: failure()
        continue-on-error: true
        run: |
          echo "Deployment failed, attempting rollback..."
          kubectl rollout undo deployment/api-gateway -n ${{ env.K8S_NAMESPACE }} || echo "No history for api-gateway"
          kubectl rollout undo deployment/auth-service -n ${{ env.K8S_NAMESPACE }} || echo "No history for auth-service"
          kubectl rollout undo deployment/community-service -n ${{ env.K8S_NAMESPACE }} || echo "No history for community-service"
          kubectl rollout undo deployment/chat-service -n ${{ env.K8S_NAMESPACE }} || echo "No history for chat-service"

      - name: Notify deployment success
        if: success()
        run: |
          echo "✅ Deployment successful!"
          echo "Image tag: ${{ steps.tag.outputs.TAG }}"
          echo "Color: ${{ steps.color.outputs.NEW_COLOR }}"
